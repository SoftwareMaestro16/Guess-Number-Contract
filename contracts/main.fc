{-
  @SoftwareMaestro: guess the number contract and its implementation
  
  Task: Develop a smart contract that implements a system where users attempt to guess a number generated by the contract, with a single type of bet.

  1. Guess the Number (`op::guess_number`): A user sends their bet along with the number they believe the contract has generated. If the user guesses the number correctly, the contract rewards them with a specified amount of TON. If the guess is incorrect, the funds remain in the contract.

  2. Set Secret Number (`op::set_secret_number`): The administrator can change the secret number that users are trying to guess. The contract saves the new number, and users continue placing bets to guess it. The administrator does not know the number.
  
  3. Administrator Withdrawal Option (`op::withdraw`): The administrator can withdraw available funds from the contract while maintaining a minimum balance for ongoing operations.

  4. Change Prize Amount (`op::change_prize_amount`): The administrator can adjust the prize amount awarded to a user for correctly guessing the number.

  5. Lock Contract (`op::lock`): The contract owner can lock the contract, preventing any further fund deposits.

  6. Unlock Contract (`op::unlock`): The contract owner can unlock the contract to resume normal operations.

  7. Change Owner (`op::change_owner`): The contract owner will be changed and the rights will be transferred.

  8. Ton Bet (`op::change_ton_bet`): Changes the user's bid.
-}

#include "imports/stdlib.fc";
#include "imports/op.fc";
#include "imports/utils.fc";

global slice storage::owner_address;
global int storage::secret_number;
global int storage::prize_amount;
global int storage::ton_bet;
global int storage::min_num;
global int storage::max_num;
global int storage::is_locked?;
global int storage::is_guessed?;

() load_data() impure inline {
    var ds = get_data().begin_parse();
        storage::owner_address = ds~load_msg_addr();
        storage::secret_number = ds~load_uint(64);
        storage::prize_amount = ds~load_uint(64);
        storage::ton_bet = ds~load_uint(64);
        storage::min_num = ds~load_uint(64);
        storage::max_num = ds~load_uint(64);
        storage::is_locked? = ds~load_uint(1);
        storage::is_guessed? = ds~load_uint(1);
    ds.end_parse();
}

() save_data() impure inline {
    set_data(
        begin_cell()
            .store_slice(storage::owner_address)
            .store_uint(storage::secret_number, 64)
            .store_uint(storage::prize_amount, 64)
            .store_uint(storage::ton_bet, 64)
            .store_uint(storage::min_num, 64)
            .store_uint(storage::max_num, 64)
            .store_uint(storage::is_locked?, 1)
            .store_uint(storage::is_guessed?, 1)
        .end_cell()
    );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return ();
    }

    slice sender = cs~load_msg_addr();
    int op = in_msg_body~load_uint(32);

    load_data();

    if (op == op::lock) {
      throw_unless(401, equal_slices(sender, storage::owner_address));
      storage::is_locked? = 1;
      save_data();

      return();
    }

    if (op == op::unlock) {
        throw_unless(401, equal_slices(sender, storage::owner_address));
        storage::is_locked? = 0;
        save_data();

        return();
    }

    if (op == op::withdraw) {
        throw_unless(401, equal_slices(sender, storage::owner_address));
        msg::send_withdraw(storage::owner_address);
        
        return();
    }

    if (op == op::change_owner) {
        throw_unless(401, equal_slices(sender, storage::owner_address));
        slice storage::owner_address = in_msg_body~load_msg_addr();
        save_data();

        return();
    }

    if (op == op::change_prize_amount) {
        throw_unless(401, equal_slices(sender, storage::owner_address));
        int storage::prize_amount = in_msg_body~load_uint(64);
        save_data();

        return();
    }

    if (op == op::change_ton_bet) {
        throw_unless(401, equal_slices(sender, storage::owner_address));
        int storage::prize_amount = in_msg_body~load_uint(64);
        save_data();

        return();
    }

    if (op == op::change_random_numbers) {
        throw_unless(401, equal_slices(sender, storage::owner_address));
        int storage::min_num = in_msg_body~load_uint(64);
        int storage::max_num = in_msg_body~load_uint(64);
        save_data();
        
        return();
    }

    if (op == op::set_secret_number) {
        throw_unless(401, equal_slices(sender, storage::owner_address));
        randomize_lt();
        int storage::secret_number = rand(storage::max_num - storage::min_num) + storage::min_num;
        int storage::is_guessed? = 0;
        save_data();

        return();
    }

    if (op == op::guess_number) {
        int received_number = in_msg_body~load_uint(64);

        if (storage::is_locked? == 1) {
            msg::send_bounce(sender, msg_value);
            throw(100);
        }
        if (storage::is_guessed? == 1) {
            msg::send_is_guessed(sender, msg_value);
            throw(777);
        }
        ifnot (msg_value == storage::ton_bet) {
            msg::send_bounce(sender, msg_value);
            throw(444);
        };
        if (received_number == storage::secret_number) {
            msg::send_prize(sender, storage::prize_amount);
            storage::is_guessed? = 1;
            save_data();
        };

        return();
    }

    throw(0xfffff);
}

;; Get Methods

(slice) get_owner() method_id {
    load_data();
    return storage::owner_address;
}

;; (int) get_secret_number() method_id {
;;     load_data();
;;     ;; return "it's not as easy as you think";
;;     return storage::secret_number;
;; }

(int) get_prize_amount() method_id {
    load_data();
    return storage::prize_amount;
}

(int) get_ton_bet() method_id {
    load_data();
    return storage::ton_bet;
}

(int) get_max_num() method_id {
  load_data();
  return storage::max_num;
}

(int) get_min_num() method_id {
  load_data();
  return storage::min_num;
}

(int) get_is_locked() method_id {
    load_data();
    return storage::is_locked?;
}

(int) get_is_guessed() method_id {
    load_data();
    return storage::is_guessed?;
}